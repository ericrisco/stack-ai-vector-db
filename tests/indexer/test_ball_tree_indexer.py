import pytest
import uuid
import numpy as np
from typing import List, Dict, Any
from unittest.mock import patch, MagicMock

from app.models.library import Library
from app.models.document import Document
from app.models.chunk import Chunk
from app.services.library_service import LibraryService
from app.services.document_service import DocumentService
from app.indexer.ball_tree_indexer import BallTreeIndexer, BallTree


@pytest.fixture
def mock_library():
    """Create a mock library for testing"""
    return Library(
        id=uuid.uuid4(),
        name="Test Library",
        metadata={"test": "data"}
    )


@pytest.fixture
def mock_documents_with_chunks(mock_library):
    """Create mock documents with chunks for testing"""
    documents = []
    
    for i in range(2):
        doc = Document(
            id=uuid.uuid4(),
            library_id=mock_library.id,
            name=f"Document {i}",
            metadata={"doc_index": str(i)}
        )
        
        # Add chunks to document without embeddings
        doc.chunks = []
        for j in range(3):
            chunk = Chunk(
                id=uuid.uuid4(),
                document_id=doc.id,
                text=f"This is test chunk {j} of document {i}",
                # No embedding - will be generated by indexer
                embedding=None,
                metadata={"position": str(j), "test": "metadata"}
            )
            doc.chunks.append(chunk)
        
        documents.append(doc)
    
    return documents


@pytest.fixture
def mock_documents_with_embeddings(mock_library):
    """Create mock documents with chunks that already have embeddings"""
    documents = []
    
    for i in range(2):
        doc = Document(
            id=uuid.uuid4(),
            library_id=mock_library.id,
            name=f"Document {i}",
            metadata={"doc_index": str(i)}
        )
        
        # Add chunks to document with pre-computed embeddings
        doc.chunks = []
        for j in range(3):
            chunk = Chunk(
                id=uuid.uuid4(),
                document_id=doc.id,
                text=f"This is test chunk {j} of document {i}",
                embedding=[0.1 * (j + 1), 0.2 * (j + 1), 0.3 * (j + 1)],
                metadata={"position": str(j), "test": "metadata"}
            )
            doc.chunks.append(chunk)
        
        documents.append(doc)
    
    return documents


@pytest.fixture
def indexer():
    """Create a BallTreeIndexer instance"""
    return BallTreeIndexer(leaf_size=2)  # Small leaf size for testing


class TestBallTreeIndexer:
    """Tests for the BallTreeIndexer class"""
    
    def test_get_indexer_name(self, indexer):
        """Test that the indexer name is correct"""
        assert indexer.get_indexer_name() == "BALL_TREE"
    
    def test_get_indexer_info_empty(self, indexer):
        """Test indexer info with no indexed libraries"""
        info = indexer.get_indexer_info()
        
        assert info["name"] == "BALL_TREE"
        assert "description" in info
        assert info["indexed_libraries"] == 0
        assert info["total_vectors"] == 0
        assert "algorithm_properties" in info
        assert info["leaf_size"] == 2  # Custom leaf size from fixture
    
    @pytest.mark.asyncio
    async def test_index_library_with_embeddings(self, indexer, mock_library, mock_documents_with_embeddings):
        """Test indexing a library with pre-computed embeddings"""
        # Mock the library and document services
        with patch('app.services.library_service.LibraryService.get_library') as mock_get_library, \
             patch('app.services.document_service.DocumentService.get_documents_by_library') as mock_get_docs:
            
            mock_get_library.return_value = mock_library
            mock_get_docs.return_value = mock_documents_with_embeddings
            
            # Index the library
            result = await indexer.index_library(mock_library.id)
            
            # Verify the result
            assert result["library_id"] == mock_library.id
            assert result["library_name"] == mock_library.name
            assert result["total_documents"] == 2
            assert result["total_chunks"] == 6  # 2 documents * 3 chunks each
            assert result["indexer"] == "BALL_TREE"
            assert "processing_time_seconds" in result
            
            # Verify internal state
            assert mock_library.id in indexer.vectors
            assert len(indexer.vectors[mock_library.id]) == 6
            assert mock_library.id in indexer.chunk_info
            assert len(indexer.chunk_info[mock_library.id]) == 6
            assert mock_library.id in indexer.trees
            assert indexer.trees[mock_library.id] is not None
    
    @pytest.mark.asyncio
    async def test_index_library_generate_embeddings(self, indexer, mock_library, mock_documents_with_chunks):
        """Test indexing a library and generating embeddings on-the-fly"""
        # Mock the library and document services
        with patch('app.services.library_service.LibraryService.get_library') as mock_get_library, \
             patch('app.services.document_service.DocumentService.get_documents_by_library') as mock_get_docs, \
             patch('app.services.embedding_service.EmbeddingService.generate_embedding') as mock_gen_embedding:
            
            mock_get_library.return_value = mock_library
            mock_get_docs.return_value = mock_documents_with_chunks
            mock_gen_embedding.return_value = [0.1, 0.2, 0.3]
            
            # Index the library
            result = await indexer.index_library(mock_library.id)
            
            # Verify the embedding service was called for each chunk
            assert mock_gen_embedding.call_count == 6  # Should be called for each chunk
            
            # Verify the result
            assert result["total_chunks"] == 6
            assert mock_library.id in indexer.vectors
            assert len(indexer.vectors[mock_library.id]) == 6
    
    @pytest.mark.asyncio
    async def test_search_with_results(self, indexer, mock_library, mock_documents_with_embeddings):
        """Test searching with valid results"""
        # First index some content
        with patch('app.services.library_service.LibraryService.get_library') as mock_get_library, \
             patch('app.services.document_service.DocumentService.get_documents_by_library') as mock_get_docs, \
             patch('app.services.embedding_service.EmbeddingService.generate_embedding') as mock_gen_embedding:
            
            mock_get_library.return_value = mock_library
            mock_get_docs.return_value = mock_documents_with_embeddings
            
            # Create a mock query embedding that will match our test data
            mock_query_embedding = [0.3, 0.6, 0.9]
            mock_gen_embedding.return_value = mock_query_embedding
            
            # Index the library
            await indexer.index_library(mock_library.id)
            
            # Perform a search
            results = await indexer.search("test query", mock_library.id, top_k=3)
            
            # Verify results
            assert len(results) == 3
            assert all("similarity_score" in r for r in results)
            assert all("chunk_id" in r for r in results)
            assert all("document_id" in r for r in results)
            assert all("text" in r for r in results)
            assert all("search_metadata" in r for r in results)
            
            # Verify scores are in descending order
            scores = [r["similarity_score"] for r in results]
            assert scores == sorted(scores, reverse=True)
    
    @pytest.mark.asyncio
    async def test_search_empty_library(self, indexer, mock_library):
        """Test searching an empty library"""
        # Mock empty vectors and chunk info
        indexer.trees[mock_library.id] = None
        indexer.vectors[mock_library.id] = np.array([], dtype=np.float32)
        indexer.chunk_info[mock_library.id] = []
        
        with patch('app.services.embedding_service.EmbeddingService.generate_embedding') as mock_gen_embedding:
            mock_gen_embedding.return_value = [0.1, 0.2, 0.3]
            
            # Search the empty library
            results = await indexer.search("test query", mock_library.id)
            
            # Verify we get empty results
            assert len(results) == 0
    
    @pytest.mark.asyncio
    async def test_search_nonexistent_library(self, indexer):
        """Test searching a library that doesn't exist in the indexer"""
        non_existent_id = uuid.uuid4()
        
        with patch('app.services.embedding_service.EmbeddingService.generate_embedding') as mock_gen_embedding:
            mock_gen_embedding.return_value = [0.1, 0.2, 0.3]
            
            # Search a library that doesn't exist in our index
            results = await indexer.search("test query", non_existent_id)
            
            # Verify we get empty results
            assert len(results) == 0

    def test_ball_tree_structure(self):
        """Test that the Ball Tree structure is created correctly"""
        # Create a simple set of points and chunk infos
        points = np.array([
            [1.0, 0.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 0.0, 1.0],
            [1.0, 1.0, 0.0],
            [0.0, 1.0, 1.0],
            [1.0, 0.0, 1.0]
        ], dtype=np.float32)
        
        chunk_infos = [
            {"id": i, "text": f"Chunk {i}"} for i in range(len(points))
        ]
        
        # Create a Ball Tree with a small leaf size
        tree = BallTree(leaf_size=2)
        tree.build(points, chunk_infos)
        
        # Verify the tree structure
        assert tree.root is not None
        assert tree.points is not None
        assert tree.chunk_infos is not None
        assert len(tree.points) == len(points)
        assert len(tree.chunk_infos) == len(chunk_infos)
        
        # The root should have children since we have more points than leaf_size
        assert tree.root.left is not None
        assert tree.root.right is not None
        
    def test_ball_tree_search(self):
        """Test Ball Tree search functionality"""
        # Create a simple set of points and chunk infos
        points = np.array([
            [1.0, 0.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 0.0, 1.0],
            [1.0, 1.0, 0.0],
            [0.0, 1.0, 1.0],
            [1.0, 0.0, 1.0]
        ], dtype=np.float32)
        
        chunk_infos = [
            {"id": i, "text": f"Chunk {i}"} for i in range(len(points))
        ]
        
        # Create a Ball Tree with a small leaf size
        tree = BallTree(leaf_size=2)
        tree.build(points, chunk_infos)
        
        # Search for the nearest neighbor to [1.0, 0.0, 0.0]
        query = np.array([1.0, 0.0, 0.0], dtype=np.float32)
        results = tree.search(query, k=1)
        
        # The nearest point should be the first point
        assert len(results) == 1
        dist, info = results[0]
        assert info["id"] == 0
        assert info["text"] == "Chunk 0"
        
        # Search for 3 nearest neighbors to [0.5, 0.5, 0.5]
        query = np.array([0.5, 0.5, 0.5], dtype=np.float32)
        results = tree.search(query, k=3)
        
        # We should get 3 results
        assert len(results) == 3 