import pytest
import uuid
import numpy as np
from typing import List, Dict, Any
from unittest.mock import patch, MagicMock

from app.models.library import Library
from app.models.document import Document
from app.models.chunk import Chunk
from app.services.library_service import LibraryService
from app.services.document_service import DocumentService
from app.indexer.brute_force_indexer import BruteForceIndexer


@pytest.fixture
def mock_library():
    """Create a mock library for testing"""
    return Library(
        id=uuid.uuid4(),
        name="Test Library",
        metadata={"test": "data"}
    )


@pytest.fixture
def mock_documents_with_chunks(mock_library):
    """Create mock documents with chunks for testing"""
    documents = []
    
    for i in range(2):
        doc = Document(
            id=uuid.uuid4(),
            library_id=mock_library.id,
            name=f"Document {i}",
            metadata={"doc_index": str(i)}
        )
        
        # Add chunks to document without embeddings
        doc.chunks = []
        for j in range(3):
            chunk = Chunk(
                id=uuid.uuid4(),
                document_id=doc.id,
                text=f"This is test chunk {j} of document {i}",
                # No embedding - will be generated by indexer
                embedding=None,
                metadata={"position": str(j), "test": "metadata"}
            )
            doc.chunks.append(chunk)
        
        documents.append(doc)
    
    return documents


@pytest.fixture
def mock_documents_with_embeddings(mock_library):
    """Create mock documents with chunks that already have embeddings"""
    documents = []
    
    for i in range(2):
        doc = Document(
            id=uuid.uuid4(),
            library_id=mock_library.id,
            name=f"Document {i}",
            metadata={"doc_index": str(i)}
        )
        
        # Add chunks to document with pre-computed embeddings
        doc.chunks = []
        for j in range(3):
            chunk = Chunk(
                id=uuid.uuid4(),
                document_id=doc.id,
                text=f"This is test chunk {j} of document {i}",
                embedding=[0.1 * (j + 1), 0.2 * (j + 1), 0.3 * (j + 1)],
                metadata={"position": str(j), "test": "metadata"}
            )
            doc.chunks.append(chunk)
        
        documents.append(doc)
    
    return documents


@pytest.fixture
def indexer():
    """Create a BruteForceIndexer instance"""
    return BruteForceIndexer()


class TestBruteForceIndexer:
    """Tests for the BruteForceIndexer class"""
    
    def test_get_indexer_name(self, indexer):
        """Test that the indexer name is correct"""
        assert indexer.get_indexer_name() == "BRUTE_FORCE"
    
    def test_get_indexer_info_empty(self, indexer):
        """Test indexer info with no indexed libraries"""
        info = indexer.get_indexer_info()
        
        assert info["name"] == "BRUTE_FORCE"
        assert "description" in info
        assert info["indexed_libraries"] == 0
        assert info["total_vectors"] == 0
        assert "algorithm_properties" in info
    
    @pytest.mark.asyncio
    async def test_index_library_with_embeddings(self, indexer, mock_library, mock_documents_with_embeddings):
        """Test indexing a library with pre-computed embeddings"""
        # Mock the library and document services
        with patch('app.services.library_service.LibraryService.get_library') as mock_get_library, \
             patch('app.services.document_service.DocumentService.get_documents_by_library') as mock_get_docs:
            
            mock_get_library.return_value = mock_library
            mock_get_docs.return_value = mock_documents_with_embeddings
            
            # Index the library
            result = await indexer.index_library(mock_library.id)
            
            # Verify the result
            assert result["library_id"] == mock_library.id
            assert result["library_name"] == mock_library.name
            assert result["total_documents"] == 2
            assert result["total_chunks"] == 6  # 2 documents * 3 chunks each
            assert result["indexer"] == "BRUTE_FORCE"
            assert "processing_time_seconds" in result
            
            # Verify internal state
            assert mock_library.id in indexer.vectors
            assert len(indexer.vectors[mock_library.id]) == 6
            assert mock_library.id in indexer.chunk_info
            assert len(indexer.chunk_info[mock_library.id]) == 6
    
    @pytest.mark.asyncio
    async def test_index_library_generate_embeddings(self, indexer, mock_library, mock_documents_with_chunks):
        """Test indexing a library and generating embeddings on-the-fly"""
        # Mock the library and document services
        with patch('app.services.library_service.LibraryService.get_library') as mock_get_library, \
             patch('app.services.document_service.DocumentService.get_documents_by_library') as mock_get_docs, \
             patch('app.services.embedding_service.EmbeddingService.generate_embedding') as mock_gen_embedding:
            
            mock_get_library.return_value = mock_library
            mock_get_docs.return_value = mock_documents_with_chunks
            mock_gen_embedding.return_value = [0.1, 0.2, 0.3]
            
            # Index the library
            result = await indexer.index_library(mock_library.id)
            
            # Verify the embedding service was called for each chunk
            assert mock_gen_embedding.call_count == 6  # Should be called for each chunk
            
            # Verify the result
            assert result["total_chunks"] == 6
            assert mock_library.id in indexer.vectors
            assert len(indexer.vectors[mock_library.id]) == 6
    
    @pytest.mark.asyncio
    async def test_search_with_results(self, indexer, mock_library, mock_documents_with_embeddings):
        """Test searching with valid results"""
        # First index some content
        with patch('app.services.library_service.LibraryService.get_library') as mock_get_library, \
             patch('app.services.document_service.DocumentService.get_documents_by_library') as mock_get_docs, \
             patch('app.services.embedding_service.EmbeddingService.generate_embedding') as mock_gen_embedding:
            
            mock_get_library.return_value = mock_library
            mock_get_docs.return_value = mock_documents_with_embeddings
            
            # Create a mock query embedding that will match our test data
            mock_query_embedding = [0.3, 0.6, 0.9]
            mock_gen_embedding.return_value = mock_query_embedding
            
            # Index the library
            await indexer.index_library(mock_library.id)
            
            # Perform a search
            results = await indexer.search("test query", mock_library.id, top_k=3)
            
            # Verify results
            assert len(results) == 3
            assert all("similarity_score" in r for r in results)
            assert all("chunk_id" in r for r in results)
            assert all("document_id" in r for r in results)
            assert all("text" in r for r in results)
            assert all("search_metadata" in r for r in results)
            
            # Verify scores are in descending order
            scores = [r["similarity_score"] for r in results]
            assert scores == sorted(scores, reverse=True)
    
    @pytest.mark.asyncio
    async def test_search_empty_library(self, indexer, mock_library):
        """Test searching an empty library"""
        # Mock empty vectors and chunk info
        indexer.vectors[mock_library.id] = []
        indexer.chunk_info[mock_library.id] = []
        
        with patch('app.services.embedding_service.EmbeddingService.generate_embedding') as mock_gen_embedding:
            mock_gen_embedding.return_value = [0.1, 0.2, 0.3]
            
            # Search the empty library
            results = await indexer.search("test query", mock_library.id)
            
            # Verify we get empty results
            assert len(results) == 0
    
    @pytest.mark.asyncio
    async def test_search_nonexistent_library(self, indexer):
        """Test searching a library that doesn't exist in the indexer"""
        non_existent_id = uuid.uuid4()
        
        with patch('app.services.embedding_service.EmbeddingService.generate_embedding') as mock_gen_embedding:
            mock_gen_embedding.return_value = [0.1, 0.2, 0.3]
            
            # Search a library that doesn't exist in our index
            results = await indexer.search("test query", non_existent_id)
            
            # Verify we get empty results
            assert len(results) == 0 